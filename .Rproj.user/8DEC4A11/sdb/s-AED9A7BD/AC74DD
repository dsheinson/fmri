{
    "contents" : "source(\"dlm_ar_functions.r\")\nrequire(dlm)\n\n# Set data and graphics paths\ndpath = \"../data/\"\ngpath = \"../graphs/\"\n\n# Load basis function\nconv = read.csv(paste(dpath,\"basis.csv\",sep=\"\"),header=FALSE)[,1]\nregions = c(\"region-frontalpole-left\",\"region-IPS-left\",\"region-IPS-right\",\"region-primaryvisual\",\"region-secondaryvisual-left\",\"region-secondaryvisual-right\")\nmod = c(\"M011\",\"M101\",\"M010\",\"M001\")\nnt = length(conv)\nNr = length(regions)\nnm = length(mod)\n\n# Load data: 5 by 5 by 5 voxel clusters from 6 different brain regions\ny = array(NA, c(125, nt+6, Nr))\nfor(i in 1:Nr) y[,,i] = as.matrix(read.csv(paste(dpath,regions[i],\".csv\",sep=\"\"),header=F))\n\n# Fit voxels to M101, M011, M010, M001 models using maximum likelihood estimation\nNv = 125\nmle = array(NA, c(Nv, 5, Nr, nm)); dimnames(mle)[[2]] = expression(beta[0],beta[1],phi,sigma[s]^2,sigma[m]^2); dimnames(mle)[[3]] = regions; dimnames(mle)[[4]] = mod\nx = array(NA, c(Nv, nt+1, 3, Nr, nm)); dimnames(mle)[[3]] = regions; dimnames(mle)[[4]] = mod\nconverge = array(0, c(Nv, Nr, nm)); dimnames(mle)[[3]] = regions; dimnames(mle)[[4]] = mod\nerror = array(0, c(Nv, Nr, nm)); dimnames(mle)[[3]] = regions; dimnames(mle)[[4]] = mod\n\n# Fit voxels to M101, M011, and M010 models\nfor(k in 1:nm)\n{\n  U = cbind(1,conv)\n  if(strsplit(mod[k],\"\")[[1]][2] == \"1\") f = conv else f = rep(1, nt)\n  for(i in 1:Nr)\n  {\n    for(j in 1:Nv)\n    {\n      if(mod[k] == \"M011\" & (i == 3 & j == 12) | (i == 5 & j == 51) | (i == 6 & j == 69) | (i == 6 & j == 116))\n      {\n        error[j,i,k] = 1\n        print(c(i,j,k,error[j,i,k],converge[j,i,k]))\n      } else {\n        fit0 = lm(y[j,-(1:6),i] ~ conv)\n        phi.init = cor(fit0$residuals[1:(nt-1)], fit0$residuals[2:nt])\n        sigma2.init = summary(fit0)$sigma^2\n        if(mod[k] == \"M001\")\n        {\n          mle[j,c(1,2,5),i,k] = c(fit0$coef, sigma2.init)\n        } else if(mod[k] == \"M010\") {\n          fit <- try(arima(y[j,-(1:6),i], order=c(1,0,0), transform.par=FALSE, xreg=conv), silent=TRUE)\n          if(class(fit) == \"try-error\")\n          {\n            error[j,i,k] = 1\n          } else {\n            converge[j,i,k] = fit$code\n            mle[j,1:4,i,k] = c(fit$coef[2:3],fit$coef[1],fit$sigma2)\n            s = dlmSmooth(dlmFilter(y[j,-(1:6),i], build.ar1(c(fit$coef[1], log(fit$sigma2), 1), U, f)))\n            x[j,,1,i,k] = s$s[,3]\n            var.x = sapply(dlmSvd2var(s$U.S, s$D.S), function(v) v[3,3])\n            x[j,,2,i,k] = s$s[,3] - 1.96*sqrt(var.x)\n            x[j,,3,i,k] = s$s[,3] + 1.96*sqrt(var.x)\n          }\n        } else {\n          fit <- try(dlmMLE(y[j,-(1:6),i], c(phi.init,log(sigma2.init/2),log(sigma2.init/2)), function(par) build.ar1(par, U, f)), silent=TRUE)\n          if(class(fit) == \"try-error\")\n          {\n            error[j,i,k] = 1\n          } else {\n            converge[j,i,k] = fit$convergence\n            s = dlmSmooth(dlmFilter(y[j,-(1:6),i], build.ar1(fit$par, U, f)))\n            mle[j,,i,k] = c(s$s[nt+1,1:2],fit$par[1],exp(fit$par[2:3]))\n            x[j,,1,i,k] = s$s[,3]\n            var.x = sapply(dlmSvd2var(s$U.S, s$D.S), function(v) v[3,3])\n            x[j,,2,i,k] = s$s[,3] - 1.96*sqrt(var.x)\n            x[j,,3,i,k] = s$s[,3] + 1.96*sqrt(var.x)\n          }\n        }\n      }\n      print(c(i,j,k,error[j,i,k],converge[j,i,k]))\n    }\n  }\n}\n\n# Save output\nout = list(mle=mle,x=x,converge=converge,error=error)\nsave(out, file=paste(dpath,\"craig_mle.rdata\",sep=\"\"))\n",
    "created" : 1402966815081.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3218602137",
    "id" : "AC74DD",
    "lastKnownWriteTime" : 1402785641,
    "path" : "~/UCSB - Research/fmri/code/craig_mle.r",
    "project_path" : "craig_mle.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}